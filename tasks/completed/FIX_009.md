# FIX_009: Hook & Function Type Issues

**Priority**: MEDIUM
**Estimated Time**: 45-60 minutes
**Files Affected**: 6 errors across 3 files

## Overview

Type issues in custom hooks, API client interceptors, form handlers, and WizardStore data management.

## Errors to Fix

### 1. useGoal Hook Nullable Boolean Types (2 errors)
**File**: `src/hooks/useGoal.ts:382, 383`

```typescript
// ERROR: Type 'boolean | null' is not assignable to type 'boolean'
return {
  // ...other properties
  canEdit,    // ❌ Line 382 - can be null
  canDelete,  // ❌ Line 383 - can be null
};

// Where interface expects:
interface UseGoalResult {
  canEdit: boolean;   // Expects boolean, not boolean | null
  canDelete: boolean; // Expects boolean, not boolean | null
}
```

### 2. API Client Error Interceptor Type (1 error)
**File**: `src/lib/api/client.ts:446`

```typescript
// ERROR: Argument of type 'unknown' is not assignable to parameter of type 'ApiError'
processedError = await interceptor.onRejected(processedError);
```

### 3. TaskEditor Form Submit Handler Mismatch (1 error)
**File**: `src/components/TaskEditor/TaskEditor.tsx:562`

```typescript
// ERROR: handleSave type incompatible with handleSubmit expectation
<Button onClick={handleSubmit(handleSave)} disabled={isSaving || isLoading}>
```

### 4. WizardStore Data Type Assignment (1 error)
**File**: `src/lib/state/goals/wizardStore.ts:627`

```typescript
// ERROR: Complex type mismatch in step data assignment
state.data[step] = initialStepData[step];
```

### 5. WizardStore Null Access (1 error)
**File**: `src/lib/state/goals/wizardStore.ts:1005`

```typescript
// ERROR: Object is possibly 'null'
get().deleteDraft(get().currentDraft.id); // currentDraft might be null
```

## Solution Strategy

### 1. Fix useGoal Nullable Booleans

Convert null values to false or ensure proper boolean return:

```typescript
// Option A: Convert null to false
const useGoalResult: UseGoalResult = {
  // ...other properties
  canEdit: canEdit ?? false,    // ✅ Converts null to false
  canDelete: canDelete ?? false, // ✅ Converts null to false
};

// Option B: Update interface to allow null
interface UseGoalResult {
  canEdit: boolean | null;   // Allow null if that's the intended behavior
  canDelete: boolean | null; // Allow null if that's the intended behavior
}

// Option C: Ensure null is never returned from source
const canEdit = useMemo(() => {
  // Logic that always returns boolean, never null
  return Boolean(someCondition);
}, [dependencies]);
```

### 2. Fix API Error Interceptor Type

Add proper type assertion or type guard:

```typescript
// Option A: Type assertion (if you're sure it's ApiError)
processedError = await interceptor.onRejected(processedError as ApiError);

// Option B: Type guard (safer approach)
if (isApiError(processedError)) {
  processedError = await interceptor.onRejected(processedError);
}

// Option C: Update interceptor signature to handle unknown
interface ErrorInterceptor {
  onRejected: (error: unknown) => Promise<ApiError>;
}
```

### 3. Fix TaskEditor Form Handler

Align handleSave signature with react-hook-form expectations:

```typescript
// Current issue: handleSave expects different signature than handleSubmit provides

// Option A: Update handleSave to match SubmitHandler
const handleSave: SubmitHandler<TaskFormData> = async (data) => {
  // Implementation using form data
  await onSave(transformFormDataToTask(data));
};

// Option B: Create wrapper function
const handleSubmitWrapper = (data: TaskFormData) => {
  handleSave(); // Call existing handleSave without parameters
};

<Button onClick={handleSubmit(handleSubmitWrapper)} />
```

### 4. Fix WizardStore Data Assignment

Add proper type constraints and checks:

```typescript
// Add proper typing for step data assignment
const updateStepData = <T extends keyof WizardFormData>(
  step: T,
  data: WizardFormData[T]
) => {
  set((state) => {
    state.data[step] = data; // Now properly typed
  });
};

// Or add runtime check
if (initialStepData[step] && isValidStepData(step, initialStepData[step])) {
  state.data[step] = initialStepData[step];
}
```

### 5. Fix Null Access in WizardStore

Add null check before accessing currentDraft:

```typescript
// Before
get().deleteDraft(get().currentDraft.id); // ❌ currentDraft might be null

// After
const { currentDraft } = get();
if (currentDraft) {
  get().deleteDraft(currentDraft.id); // ✅ Safe access
}

// Or update interface to indicate currentDraft can't be null in this context
```

## Implementation Steps

### Phase 1: Fix Hook Return Types (15 minutes)
1. **Analyze useGoal hook logic** to understand when null is returned
2. **Choose approach** (convert to boolean vs allow null in interface)
3. **Update implementation** consistently
4. **Test hook usage** in components

### Phase 2: Fix API Error Types (10 minutes)
1. **Check ApiError type definition** and interceptor usage
2. **Add proper type handling** for error interceptor
3. **Test error handling flow** with proper types

### Phase 3: Fix Form Handler (15 minutes)
1. **Align handleSave signature** with react-hook-form requirements
2. **Update form submission flow** to work with proper types
3. **Test form submission** and validation

### Phase 4: Fix WizardStore Issues (15 minutes)
1. **Add null checks** for currentDraft access
2. **Improve type safety** for step data assignments
3. **Test wizard functionality** with edge cases

## Files to Modify

- [ ] `src/hooks/useGoal.ts` - Fix nullable boolean returns
- [ ] `src/lib/api/client.ts` - Fix error interceptor typing
- [ ] `src/components/TaskEditor/TaskEditor.tsx` - Fix form submit handler
- [ ] `src/lib/state/goals/wizardStore.ts` - Fix data assignment and null access

## Specific Implementation

### useGoal Hook Fix
```typescript
// In useGoal.ts
const useGoal = (goalId: string): UseGoalResult => {
  // ... hook logic

  // Ensure boolean return (Option A - recommended)
  return {
    goal,
    loading,
    error,
    canEdit: Boolean(canEdit),    // ✅ Always boolean
    canDelete: Boolean(canDelete), // ✅ Always boolean
    // ... other properties
  };
};
```

### API Error Interceptor Fix
```typescript
// In api/client.ts
try {
  // ... request logic
} catch (error) {
  let processedError: ApiError = normalizeError(error); // Convert to ApiError

  for (const interceptor of errorInterceptors) {
    if (interceptor.onRejected) {
      processedError = await interceptor.onRejected(processedError); // ✅ Type-safe
    }
  }

  throw processedError;
}
```

### TaskEditor Form Handler Fix
```typescript
// In TaskEditor.tsx
const handleSave: SubmitHandler<TaskFormData> = async (formData) => {
  const taskData = formDataToTask(formData); // Transform data
  await onSave(taskData); // Call prop with transformed data
};

// Button usage remains the same
<Button onClick={handleSubmit(handleSave)} disabled={isSaving || isLoading}>
```

### WizardStore Fixes
```typescript
// Fix null access
const deleteDraftAction = () => {
  const state = get();
  if (state.currentDraft?.id) { // ✅ Safe null check
    state.deleteDraft(state.currentDraft.id);
  }
};

// Fix step data assignment with better typing
const setStepData = (step: WizardStep, data: unknown) => {
  set((state) => {
    if (isValidStepData(step, data)) {
      state.data[step] = data as WizardFormData[typeof step]; // ✅ Type-safe
    }
  });
};
```

## Testing Checklist

- [ ] useGoal hook returns proper boolean values
- [ ] API error handling works with interceptors
- [ ] TaskEditor form submission works correctly
- [ ] WizardStore handles null cases gracefully
- [ ] All TypeScript errors resolved
- [ ] No runtime errors introduced

## Impact Assessment

- **Medium Priority**: These fixes improve type safety and prevent potential runtime errors
- **User Experience**: Better error handling and form validation
- **Developer Experience**: Cleaner APIs and better IntelliSense

## Dependencies

- Should be completed after FIX_001 (critical type fixes)
- Can be worked on in parallel with other non-critical fixes